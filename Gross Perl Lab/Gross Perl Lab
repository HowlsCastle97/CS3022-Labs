#!/usr/bin/perl
use strict;
use warnings;
use Scalar::Util qw(looks_like_number);
use Time::HiRes qw(sleep);

# Fortune Escalator
# Run: perl fortune_escalator.pl
#
# Interactive script that gives progressively darker/weirder fortunes.
# Type 'quit' or 'exit' to bail. Press Enter on an empty line for the next fortune.

$| = 1; # autoflush

# --- configuration ---
my @levels = (
    # Level 0: benign / cute
    [
        "A small surprise will brighten your tomorrow.",
        "You will find a forgotten $'s coin in a pocket you thought empty.",
        "Someone will compliment your haircut today.",
        "Your next coffee will be exactly the temperature you like."
    ],
    # Level 1: cheeky / playful
    [
        "An old friend will text you at an inconvenient hour and ruin your bedtime plans.",
        "You will finally win an argument on the internet. Revel briefly, then move on.",
        "Your socks will go missing in the laundry; the dryer will offer no apologies.",
        "That 'quick errand' will take twice as long and cost extra gas."
    ],
    # Level 2: snarky / dark humor
    [
        "You will be remembered fondly in the obituary of a vending machine.",
        "Somebody will call you 'sir' and you'll accept it like a bargain.",
        "Your future self will send back a postcard: 'Stop doing that. —You'",
        "You will misplace your keys, and they'll be exactly where you left them last time."
    ],
    # Level 3: edgy / dark-but-not-graphic
    [
        "You will survive today's tiny disasters to compile a legendary 'war story' for drinks later.",
        "A plan so stupid will work that it will become a dangerous habit.",
        "One day you'll tell a story that makes everyone laugh and then regret it for a week.",
        "You will accidentally adopt responsibility for something you did not sign up for."
    ],
    # Level 4: surreal / bleakly funny
    [
        "The universe will give you a 'you tried' sticker. Frame it, sell prints.",
        "Your future tardy excuse will be a highly specific natural disaster involving pigeons.",
        "A minor betrayal will arrive by certified letter; keep the coffee nearby.",
        "You'll achieve a victory so small it will be archived in museums of questionable taste."
    ],
    # Level 5: dark wry (last escalation)
    [
        "If today were a movie, it would be a black comedy with polite applause at the end.",
        "Your mistakes will one day be turned into karaoke hits. Prepare backup harmonies.",
        "When asked for your legacy, please keep it to one sentence. The committee appreciates brevity.",
        "You will be haunted only by your own good decisions; they'll expect sequels."
    ],
);

# small pool of personalized callbacks (safe, fun)
my @callbacks = (
    "a coffee stain shaped suspiciously like %s's future",
    "a voicemail that begins with 'you'll never guess' and then tells you something boring",
    "a parking spot with a deadline that courteously moves elsewhere",
    "a free snack that will be gone by the time you decide you're hungry enough"
);

# friendly intro
print "\n=== Fortune Escalator v1.0 ===\n";
print "Give me a name (or press Enter to stay mysterious): ";
chomp(my $name = <STDIN>);
$name = $name =~ /\S/ ? $name : "Stranger";

# seed RNG with name and time so fortunes feel personalized but reproducible in short term
my $seed = 0;
$seed += ord($_) for split //, $name;
$seed += time % 997; # some time variance
srand($seed);

print "\nHello, $name. Fortune style: playful → uncomfortable → legendary.\n";
print "Press Enter to receive a fortune. Type 'quit' or 'exit' to stop. Type 'reveal' to end with a polite bow.\n\n";

my $level = 0;
my $since_start = 0;

FORT_LOOP: while (1) {
    print "[level $level] > ";
    chomp(my $input = <STDIN>);
    last FORT_LOOP if !defined $input;      # EOF
    $input =~ s/^\s+|\s+$//g;

    if (lc $input eq 'quit' or lc $input eq 'exit') {
        print "\nAlright, soldier. Fortune shift aborted. Go be excellent.\n";
        last FORT_LOOP;
    }
    if (lc $input eq 'reveal') {
        print "\nPulling the curtain: this is a scripted fortune escalator. No one knows your secrets.\n";
        last FORT_LOOP;
    }

    # slight theatrical delay
    my $dramatic = 0.02 + rand() * 0.09;
    for my $c (split //, "thinking") {
        print $c;
        sleep($dramatic);
    }
    print "\n";

    # choose a fortune from current level; occasionally escalate faster
    my $fortune = $levels[$level]->[ int rand @{ $levels[$level] } ];

    # 30% chance to personalize with a callback that uses the name
    if (rand() < 0.3) {
        my $cb = $callbacks[int rand @callbacks];
        $cb =~ s/%s/$name/g;
        $fortune .= " Also: expect " . $cb . ".";
    }

    # lightly "corrupt" some fortunes at higher levels for flavor
    if ($level >= 3 && rand() < 0.4) {
        $fortune = corrupt_line($fortune);
    }

    # print with a messy flourish (random punctuation, ellipses)
    print mutate_print($fortune);

    $since_start++;

    # escalate level based on number of fortunes requested and random chance
    if ($since_start > 1 && rand() < 0.35) {
        $level++ if $level < $#levels;
    } else {
        # deterministic fallback: every 3 fortunes -> climb a level
        $level = $since_start / 3 if $since_start % 3 == 0;
        $level = int($level) > $#levels ? $#levels : int($level);
    }

    # small chance to reset back to a cute fortune (keeps people guessing)
    if (rand() < 0.08) {
        print "(the cosmos blinks; mood reset)\n";
        $level = 0;
    }

    # guard: if they've hit the top, keep giving top-level style but occasionally tease
    if ($level >= $#levels) {
        if (rand() < 0.25) {
            print "(final boss mode)\n";
        }
    }

    print "\n";
}

print "\nGood fortune (or whatever passes for it) to you, $name. Exit with pride.\n";

# --- helper subs ---

sub mutate_print {
    my ($text) = @_;
    # random punctuation
    $text =~ s/([.?!])$/$1 x 1/eg;
    $text =~ s/,$/, and then/g if rand() < 0.15;
    # sometimes add a whispered aside
    if (rand() < 0.22) {
        $text .= " (whispers: \"" . short_side_note() . "\")";
    }
    # print with small per-character jitter to feel human
    for my $ch (split //, $text) {
        print $ch;
        sleep(0.005 + rand() * 0.02);
    }
    print "\n";
    return '';
}

sub short_side_note {
    my @notes = (
        "Not legally binding",
        "Probably fine",
        "Ask your therapist",
        "Do not text your ex",
        "This line may self destruct",
        "Collect stamps",
    );
    return $notes[int rand @notes];
}

sub corrupt_line {
    my ($line) = @_;
    # insert a rogue emoji or replace a word with something darker
    my @swaps = (
        ['coffee','consolation prize'],
        ['friend','fellow idiot'],
        ['surprise','spectacularly awkward coincidence'],
        ['victory','paper victory'],
        ['applause','polite clapping'],
    );
    if (rand() < 0.6) {
        my $pair = $swaps[int rand @swaps];
        $line =~ s/\b\Q$pair->[0]\E\b/$pair->[1]/ig;
    }
    # add an odd symbol occasionally
    $line .= " ~☕~" if rand() < 0.25;
    return $line;
}
